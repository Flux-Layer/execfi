// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Game Sessions - Phase 1 (Degenshoot specific)
model GameSession {
  id                String   @id
  userAddress       String?  @db.VarChar(42)
  serverSeed        String   @db.VarChar(100)
  serverSeedHash    String   @db.VarChar(100)
  clientSeed        String   @db.VarChar(100)
  createdAt         BigInt
  wagerWei          String?  @db.VarChar(100)
  nonceBase         Int
  status            String   @db.VarChar(20)
  rows              Json     @default("[]")
  currentRow        Int      @default(0)
  currentMultiplier Float    @default(1.0)
  completedRows     Int      @default(0)
  lockedTileCounts  Json     @default("[]")
  roundSummary      Json?
  finalizedAt       BigInt?
  expiresAt         DateTime
  isActive          Boolean  @default(true)
  updatedAt         DateTime @updatedAt

  // Transaction tracking fields
  wagerTxHash       String?  @db.VarChar(66)   // 0x + 64 hex chars
  resultTxHash      String?  @db.VarChar(66)   // Result submission TX
  withdrawTxHash    String?  @db.VarChar(66)   // Vault withdrawal TX (actual payout)
  xpTxHash          String?  @db.VarChar(66)   // XP claim TX
  verifiedAt        DateTime?                   // Client verification timestamp
  verifiedBy        String?  @db.VarChar(42)   // Address who verified

  @@index([userAddress])
  @@index([isActive])
  @@index([expiresAt])
  @@index([userAddress, isActive])
  @@index([status])
  @@index([createdAt])                          // For sorting history by date
  @@index([finalizedAt])                        // For filtering completed games
  @@index([userAddress, createdAt(sort: Desc)]) // Optimized for history queries
  @@map("game_sessions")
}

model CoinFlipHistory {
  id                 Int      @id @default(autoincrement())
  userAddress        String   @db.VarChar(42)
  sessionId          String?  @db.VarChar(32)
  guess              String   @db.VarChar(10)
  outcome            String   @db.VarChar(10)
  wagerWei           String   @db.VarChar(100)
  selectedMultiplier Int
  payoutMultiplier   Int
  xp                 Int
  payoutTxHash       String?  @db.VarChar(66)
  serverSeed         String?  @db.VarChar(128)
  clientSeed         String?  @db.VarChar(64)
  serverSeedHash     String?  @db.VarChar(100)
  randomValue        BigInt?
  revealedAt         DateTime?
  createdAt          DateTime @default(now())

  @@index([userAddress, createdAt])
  @@map("coinflip_history")
}

// Users - Phase 2
model User {
  address             String             @id @db.VarChar(42)
  onboardedAt         DateTime?
  tutorialCompletedAt DateTime?
  tutorialSkipped     Boolean            @default(false)
  createdAt           DateTime           @default(now())
  updatedAt           DateTime           @updatedAt
  tutorialProgress    TutorialProgress[]

  @@map("users")
}

// Tutorial Progress - Phase 2
model TutorialProgress {
  id          Int       @id @default(autoincrement())
  userAddress String    @db.VarChar(42)
  stepId      String    @db.VarChar(100)
  completed   Boolean   @default(false)
  completedAt DateTime?
  data        Json?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  user User @relation(fields: [userAddress], references: [address], onDelete: Cascade)

  @@unique([userAddress, stepId])
  @@index([userAddress])
  @@map("tutorial_progress")
}

// Device-based onboarding (replaces wallet-based for new onboarding flow)
model Device {
  id          String   @id @default(cuid())
  fingerprint String   @unique @db.VarChar(100)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  lastSeenAt  DateTime @default(now())

  // Onboarding tracking
  onboardedAt         DateTime?
  onboardingCompleted Boolean              @default(false)
  onboardingSkipped   Boolean              @default(false)
  onboardingProgress  OnboardingProgress[]

  // Optional user association (when wallet connects)
  userAddress String? @db.VarChar(42)

  // Device metadata
  userAgent String? @db.Text
  locale    String? @db.VarChar(10)
  timezone  String? @db.VarChar(50)

  @@index([fingerprint])
  @@index([userAddress])
  @@index([lastSeenAt])
  @@map("devices")
}

// Step-by-step onboarding progress
model OnboardingProgress {
  id          Int       @id @default(autoincrement())
  deviceId    String
  stepId      String    @db.VarChar(100)
  completed   Boolean   @default(false)
  completedAt DateTime?
  data        Json? // Additional step-specific data
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  device Device @relation(fields: [deviceId], references: [id], onDelete: Cascade)

  @@unique([deviceId, stepId])
  @@index([deviceId])
  @@map("onboarding_progress")
}

// ============================================
// SUNDAY QUEST SYSTEM
// ============================================

model QuestTemplate {
  id              Int             @id @default(autoincrement())
  questKey        String          @unique @db.VarChar(100)
  name            String          @db.VarChar(255)
  description     String          @db.Text
  questType       QuestType
  difficulty      QuestDifficulty
  requirements    Json
  baseXpReward    Int
  bonusMultiplier Float           @default(1.0)
  estimatedTime   Int
  iconUrl         String?         @db.VarChar(500)
  isActive        Boolean         @default(true)
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  // Relations
  userProgress UserQuestProgress[]

  @@index([questType])
  @@index([difficulty])
  @@index([isActive])
  @@map("quest_templates")
}

model WeeklyQuestRotation {
  id            Int      @id @default(autoincrement())
  weekStartDate DateTime @unique
  weekEndDate   DateTime
  questSlots    Json
  seed          String   @db.VarChar(100)
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())

  @@index([weekStartDate, isActive])
  @@map("weekly_quest_rotations")
}

model UserQuestProgress {
  id              Int         @id @default(autoincrement())
  userAddress     String      @db.VarChar(42)
  rotationId      Int
  questTemplateId Int
  status          QuestStatus
  progress        Json?
  startedAt       DateTime?
  completedAt     DateTime?
  claimedAt       DateTime?
  transactionHash String?     @db.VarChar(66)
  xpAwarded       Int?

  // Relations
  questTemplate QuestTemplate @relation(fields: [questTemplateId], references: [id])

  @@unique([userAddress, rotationId, questTemplateId])
  @@index([userAddress, status])
  @@index([rotationId])
  @@index([status])
  @@map("user_quest_progress")
}

model QuestCompletionEvent {
  id              Int      @id @default(autoincrement())
  userAddress     String   @db.VarChar(42)
  questTemplateId Int
  rotationId      Int
  completionProof Json
  verifiedAt      DateTime
  xpAwarded       Int
  transactionHash String?  @db.VarChar(66)
  createdAt       DateTime @default(now())

  @@index([userAddress])
  @@index([createdAt])
  @@map("quest_completion_events")
}

enum QuestType {
  TRANSACTION
  COMBO
  EXPLORATION
  ACHIEVEMENT
  SOCIAL
}

enum QuestDifficulty {
  EASY
  MEDIUM
  HARD
  EPIC
}

enum QuestStatus {
  AVAILABLE
  IN_PROGRESS
  PENDING_VERIFICATION
  COMPLETED
  CLAIMED
  FAILED
  EXPIRED
}
