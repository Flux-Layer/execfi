"use client";

import { useEffect, useState } from "react";
import { usePrivy } from "@privy-io/react-auth";
import { useEOA } from "@/providers/EOAProvider";
import { QuestCard } from "./QuestCard";
import { useClaimQuestXP } from "@/hooks/sunday-quest/useClaimQuestXP";
import { motion } from "framer-motion";
import { formatDistanceToNow } from "date-fns";
import toast from "react-hot-toast";

export function MalwareQuestView() {
  const { user, authenticated } = usePrivy();
  const { selectedWallet } = useEOA(); // Use the actually selected wallet!
  const { 
    claimXP, 
    isPending: isClaimPending,
  } = useClaimQuestXP();
  const [loading, setLoading] = useState(true);
  const [rotation, setRotation] = useState<any>(null);
  const [quests, setQuests] = useState<any[]>([]);

  useEffect(() => {
    loadQuests();
  }, [user]);

  async function loadQuests() {
    setLoading(true);
    try {
      // Use selectedWallet (the one that actually sends transactions) instead of user.wallet
      const address = selectedWallet?.address || user?.wallet?.address;
      // Add timestamp to bust cache
      const timestamp = Date.now();
      const url = address
        ? `/api/sunday-quest/current?address=${address}&t=${timestamp}`
        : `/api/sunday-quest/current?t=${timestamp}`;

      const res = await fetch(url, {
        cache: "no-store", // Disable Next.js cache
      });
      const data = await res.json();

      if (data.error) {
        toast.error(data.error);
        return;
      }

      setRotation(data.rotation);

      const questsWithProgress = data.quests.map((quest: any) => {
        const progress = data.userProgress?.find(
          (p: any) => p.questTemplateId === quest.id
        );
        
        console.log(`Quest ${quest.name} progress:`, progress?.progress);
        
        return {
          ...quest,
          userProgress: progress,
        };
      });

      setQuests(questsWithProgress);
    } catch (error) {
      console.error("Failed to load quests:", error);
      toast.error("Failed to load infection data");
    } finally {
      setLoading(false);
    }
  }

  async function handleStartQuest(questId: number) {
    const address = selectedWallet?.address || user?.wallet?.address;
    if (!address) {
      toast.error("Please connect your wallet to start quarantine");
      return;
    }

    try {
      const res = await fetch("/api/sunday-quest/start", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          questId,
          userAddress: address,
        }),
      });

      const data = await res.json();

      if (data.success) {
        if (data.message === "Quest already started") {
          toast.success("ü¶† Quarantine already in progress!");
        } else {
          toast.success("ü¶† Quarantine process started!");
        }
        loadQuests();
      } else {
        toast.error(data.error || "Failed to start quarantine");
      }
    } catch (error) {
      console.error("Failed to start quest:", error);
      toast.error("Failed to start quarantine");
    }
  }

  async function handleVerifyQuest(questId: number) {
    const address = selectedWallet?.address || user?.wallet?.address;
    if (!address) {
      toast.error("Please connect your wallet");
      return;
    }

    try {
      const res = await fetch("/api/sunday-quest/verify", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          questId,
          userAddress: address,
        }),
      });

      const data = await res.json();
      
      console.log("Verification response:", data);

      if (data.verified) {
        toast.success("‚úÖ Infection cleared! Claim your XP.");
        loadQuests();
      } else if (data.progress !== undefined) {
        toast.success(`Progress: ${data.progress}% - ${data.message}`);
        loadQuests();
      } else {
        toast.error(data.message || "Infection still active");
      }
    } catch (error) {
      console.error("Failed to verify quest:", error);
      toast.error("Failed to scan system");
    }
  }

  async function handleClaimQuest(questId: number) {
    // Use correct wallet address
    const address = selectedWallet?.address || user?.wallet?.address;
    
    if (!address) {
      toast.error("Please connect your wallet");
      return;
    }

    const toastId = toast.loading("üßπ Preparing to clean system...");

    try {
      // Step 1: Generate claim signature
      const claimRes = await fetch("/api/sunday-quest/claim", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          questId,
          userAddress: address, // ‚úÖ Use correct wallet
        }),
      });

      const claimData = await claimRes.json();

      if (!claimData.success) {
        toast.dismiss(toastId);
        toast.error(claimData.error || "Failed to prepare claim");
        return;
      }

      // Step 2: Submit transaction on-chain
      toast.loading("üßπ Submitting claim transaction...", { id: toastId });
      
      // Get wallet for transaction
      if (!selectedWallet) {
        toast.dismiss(toastId);
        toast.error("No wallet selected. Please select a wallet.");
        return;
      }
      
      try {
        // claimXP now uses Privy wallet directly (same as degenshoot)
        const result = await claimXP(
          claimData.payload, 
          claimData.signature as `0x${string}`,
          selectedWallet,
          address as `0x${string}`
        );
        
        console.log("Transaction hash:", result.hash);
        console.log("Transaction receipt:", result.receipt);
        
        // Step 3: Mark as claimed in database (ONLY after on-chain confirmation)
        await fetch("/api/sunday-quest/mark-claimed", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            questId,
            userAddress: address,
            transactionHash: result.hash,
          }),
        });

        toast.dismiss(toastId);
        toast.success(`‚ú® System cleaned! +${claimData.xpAwarded} XP earned!`, {
          duration: 5000,
        });

        // Reload quests to show updated state
        loadQuests();
        
      } catch (txError: any) {
        toast.dismiss(toastId);
        
        // User rejected transaction
        if (txError?.message?.includes("User rejected") || txError?.code === 4001 || txError?.message?.includes("User denied")) {
          toast.error("Transaction cancelled by user");
        } else {
          console.error("Transaction error:", txError);
          toast.error(txError?.message || "Claim transaction failed. Please try again.");
        }
        
        // Don't mark as claimed if transaction failed!
        return;
      }
      
    } catch (error: any) {
      toast.dismiss(toastId);
      console.error("Failed to claim quest:", error);
      toast.error(error?.message || "Failed to clean system");
    }
  }

  if (loading) {
    return (
      <div className="flex items-center justify-center h-full">
        <div className="text-center">
          <motion.div
            className="text-red-500 text-6xl mb-4"
            animate={{ rotate: 360 }}
            transition={{ duration: 2, repeat: Infinity, ease: "linear" }}
          >
            ‚öôÔ∏è
          </motion.div>
          <p className="text-white text-xl">Scanning system...</p>
        </div>
      </div>
    );
  }

  const completedCount = quests.filter(
    (q) => q.userProgress?.status === "CLAIMED"
  ).length;
  const totalXP = quests
    .filter((q) => q.userProgress?.xpAwarded)
    .reduce((sum, q) => sum + (q.userProgress.xpAwarded || 0), 0);

  const timeRemaining = rotation
    ? formatDistanceToNow(new Date(rotation.weekEndDate), { addSuffix: true })
    : "---";

  const infectionLevel = completedCount === 0 ? "CRITICAL" : 
                         completedCount < 3 ? "HIGH" : 
                         completedCount < 5 ? "MEDIUM" : "CLEAN";

  const infectionColor = infectionLevel === "CRITICAL" ? "text-red-500" :
                         infectionLevel === "HIGH" ? "text-orange-500" :
                         infectionLevel === "MEDIUM" ? "text-yellow-500" : "text-green-500";

  return (
    <div className="h-full overflow-y-auto">
      {/* Infection Status */}
      <div className="bg-slate-900 border-b-2 border-red-500/50 p-6">
        <div className="max-w-4xl mx-auto">
          <div className="bg-slate-800 rounded-xl p-6 border-2 border-red-600/30">
            <div className="flex items-center justify-between mb-4">
              <div>
                <div className="text-xs text-red-400 mb-1 uppercase tracking-wider">
                  System Status
                </div>
                <div className={`text-3xl font-bold ${infectionColor} flex items-center gap-2`}>
                  <motion.span
                    animate={{ scale: [1, 1.1, 1] }}
                    transition={{ duration: 1, repeat: Infinity }}
                  >
                    {infectionLevel}
                  </motion.span>
                  {infectionLevel !== "CLEAN" && <span className="text-2xl">‚ö†Ô∏è</span>}
                </div>
                <div className="text-sm text-slate-400 mt-1">
                  Quarantine expires {timeRemaining}
                </div>
              </div>
              <div className="text-right">
                <div className="text-xs text-slate-400 mb-1 uppercase tracking-wider">
                  Infections Cleared
                </div>
                <div className="text-3xl font-bold text-white">
                  {completedCount} / {quests.length}
                </div>
                <div className="text-sm text-purple-400 mt-1">
                  +{totalXP.toLocaleString()} XP Earned
                </div>
              </div>
            </div>

            {/* Progress bar */}
            <div className="h-4 bg-slate-700 rounded-full overflow-hidden relative">
              <motion.div
                className={`h-full ${
                  infectionLevel === "CLEAN" 
                    ? "bg-gradient-to-r from-green-500 to-emerald-500"
                    : "bg-gradient-to-r from-red-600 to-orange-600"
                }`}
                initial={{ width: 0 }}
                animate={{
                  width: `${quests.length > 0 ? (completedCount / quests.length) * 100 : 0}%`,
                }}
                transition={{ duration: 1, ease: "easeOut" }}
              />
              {/* Scanning effect */}
              <motion.div
                className="absolute inset-0 bg-white/20"
                initial={{ x: "-100%" }}
                animate={{ x: "200%" }}
                transition={{
                  duration: 2,
                  repeat: Infinity,
                  ease: "linear",
                }}
              />
            </div>
          </div>
        </div>
      </div>

      {/* Quest/Infection List */}
      <div className="max-w-4xl mx-auto px-6 py-6 space-y-4">
        {quests.map((quest, index) => (
          <motion.div
            key={quest.id}
            initial={{ opacity: 0, x: -20 }}
            animate={{ opacity: 1, x: 0 }}
            transition={{ delay: index * 0.1 }}
          >
            <QuestCard
              quest={quest}
              onStart={handleStartQuest}
              onVerify={handleVerifyQuest}
              onClaim={handleClaimQuest}
            />
          </motion.div>
        ))}
      </div>

      {quests.length === 0 && (
        <div className="max-w-4xl mx-auto px-6 py-12 text-center">
          <div className="text-6xl mb-4">ü¶†</div>
          <h2 className="text-2xl font-bold text-white mb-2">
            No Active Infections
          </h2>
          <p className="text-slate-400">
            Check back on Sunday for new mallware threats!
          </p>
        </div>
      )}
    </div>
  );
}
