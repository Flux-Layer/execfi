"use client";

import { useEffect, useState, useCallback } from "react";
import { usePrivy, useWallets } from "@privy-io/react-auth";
import { usePrivyEOA } from "./usePrivyEOA";
import { createSmartAccountClient } from "@biconomy/module";
import type { Address } from "viem";
import { createWalletClient, custom, http } from "viem";
import { base, mainnet, polygon, arbitrum } from "viem/chains";
import { getEmbeddedConnectedWallet } from "@privy-io/react-auth";
import {
  ECDSAOwnershipValidationModule,
  DEFAULT_ECDSA_OWNERSHIP_MODULE,
} from "@biconomy/account";
import { createConfig } from "wagmi";
import { useQueryClient } from "@tanstack/react-query";
import { useSmartAccount } from "@biconomy/use-aa";

const RPC_URLS: Record<number, string> = {
  8453: `https://base-mainnet.g.alchemy.com/v2/${process.env.NEXT_PUBLIC_ALCHEMY_KEY}`,
  1: `https://eth-mainnet.g.alchemy.com/v2/${process.env.NEXT_PUBLIC_ALCHEMY_KEY}`,
  42161: `https://arb-mainnet.g.alchemy.com/v2/${process.env.NEXT_PUBLIC_ALCHEMY_KEY}`,
  137: `https://polygon-mainnet.g.alchemy.com/v2/${process.env.NEXT_PUBLIC_ALCHEMY_KEY}`,
};

const CHAIN_MAP: Record<number, any> = {
  8453: base,
  1: mainnet,
  137: polygon,
  42161: arbitrum,
};

type UseBiconomySAReturn = {
  loading: boolean;
  error?: string;
  ownerAddress?: Address;
  saAddress?: Address;
  client?: any;
  sendTx: (params: {
    to: string;
    value?: string;
    data?: string;
  }) => Promise<any>;
  refresh: (chainId?: number) => Promise<void>;
};

export default function useBiconomySA(
  defaultChainId = 8453
): UseBiconomySAReturn {
  const queryClient = useQueryClient();

  const { ready: privyReady, authenticated } = usePrivy();
  const { ensureEOA, address: ownerAddress } = usePrivyEOA();
  const { wallets } = useWallets();

  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string>();
  const [client, setClient] = useState<any>();
  const [saAddress, setSaAddress] = useState<Address>();
  const [currentChainId, setCurrentChainId] = useState<number>(defaultChainId);

  const init = useCallback(
    async (chainId: number = defaultChainId) => {
      setError(undefined);
      setLoading(true);

      if (privyReady && ownerAddress) {
        try {
          if (!privyReady || !authenticated) {
            throw new Error("Privy not ready or user not logged in");
          }

          const eoaRes = await ensureEOA();
          if (!eoaRes) {
            throw new Error("Failed to ensure EOA");
          }
          const { address: eoaAddr, provider } = eoaRes;

          const config = createConfig({
            chains: [base],
            transports: {
              [base.id]: http(),
            },
          });

          // const smartAccount = useSmartAccount()

          console.log({ eoaAddr, provider });

          console.log({ eoaRes });

          const rpcUrl = RPC_URLS[chainId];
          if (!rpcUrl) throw new Error(`Unsupported chainId: ${chainId}`);
          console.log({ rpcUrl });

          const chain = CHAIN_MAP[chainId];
          if (!chain) throw new Error(`No viem chain config for ${chainId}`);
          console.log({ chain });

          const viemSigner = createWalletClient({
            account: eoaAddr,
            chain,
            transport: custom(provider),
          });

          const embeddedWallet = getEmbeddedConnectedWallet(wallets);

          console.log({ embeddedWallet });

          const ethersProviderFromEmbeddedWallet = (
            embeddedWallet as any
          )?.getEthersProvider?.();
          const ethereumProviderFromEmbeddedWallet =
            embeddedWallet?.getEthereumProvider?.();

          console.log({ ethereumProviderFromEmbeddedWallet });
          console.log({ ethersProviderFromEmbeddedWallet });

          const signer = provider?.getSigner?.();

          console.log({ provider });

          console.log({ signer });

          const validationModule = await ECDSAOwnershipValidationModule.create({
            signer: viemSigner,
            moduleAddress: DEFAULT_ECDSA_OWNERSHIP_MODULE, // This is a Biconomy constant
          });

          const saClient = await createSmartAccountClient({
            provider,
            signer: viemSigner,
            bundlerUrl: process.env.NEXT_PUBLIC_BICONOMY_BUNDLER!,
            paymasterUrl: process.env.NEXT_PUBLIC_BICONOMY_PAYMASTER, // Optional for MVP
            rpcUrl,
            chainId,
            defaultValidationModule: validationModule, // Use the `validationModule` we initialized above
            activeValidationModule: validationModule, // Use the `validationModule` we initialized above
          });

          console.log({ viemSigner });

          setClient(saClient);
          setCurrentChainId(chainId);

          const addr = await saClient.getAddress();
          console.log({ addr });
          setSaAddress(addr as Address);
        } catch (e: any) {
          console.error("Biconomy init error:", e);
          setError(e?.message ?? "Failed to initialize Biconomy smart account");
        } finally {
          setLoading(false);
        }
      }
    },
    [privyReady, authenticated, defaultChainId, ownerAddress] // ✅ ensureEOA tidak masuk deps
  );

  const sendTx = useCallback(
    async (request: { to: string; value?: string; data?: string }) => {
      if (!client) throw new Error("Client not initialized");

      try {
        // Use the correct Biconomy SDK format
        const { wait } = await client.sendTransaction({
          to: request.to,
          data: request?.data ?? "0x",
          value: request?.value ? BigInt(request.value) : BigInt(0),
        });

        // Wait for transaction and get the hash
        const {
          receipt: { transactionHash },
          success,
        } = await wait();

        if (!success) {
          throw new Error("Transaction failed during execution");
        }

        console.log(`✅ Tx sent on chain ${currentChainId}:`, transactionHash);
        return transactionHash;
      } catch (err) {
        console.error("Tx error:", err);
        throw err;
      }
    },
    [client, currentChainId]
  );

  useEffect(() => {
    if (privyReady && authenticated) {
      void init(defaultChainId);
    }
  }, [privyReady, authenticated, init, defaultChainId]);

  return {
    loading,
    error,
    ownerAddress: ownerAddress as Address | undefined,
    saAddress,
    client,
    sendTx,
    refresh: init,
  };
}
